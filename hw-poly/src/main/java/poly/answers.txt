## CSE 331 hw-poly Questions
## Part 0
###########################################################################
0. Addition Pseudocode = add(p, q), assuming p is a polynomial or a term and q is a polynomial or a term.
r = p + q:
    set r = q by making a term-by-term copy of all terms in q to r
    {Inv: r = q + p_0 + p_1 + ... + p_i-1, where p_j is the jth term in p}
    foreach term, t_p, in p:
        if any term, t_r, in r has the same degree as t_p,
        then replace t_r in r with the sum of t_p and tr
        else insert t_p into r as a new term

Subtraction Pseudocode = sub(p, q), assuming p is a polynomial or a term and q is a polynomial or a term.
add(p, q.negate()) // using q.negate() from RatNum.java

1. Multiplication Pseudocode = multiply(p,q), assuming p is a polynomial or a term and q is a polynomial or a term.

r = p * q:
    set r to be empty
    {Inv: r = q_0 * (p_0 + p_1 + ... + p_i-1) + q_1 * (p_0 + p_1 + ... + p_i-1) + ... + q_j-1 * (p_0 + p_1 + ... + p_i-1),
    where p_i is the ith term in p and q_j is the jth term in q}
    foreach term, t_q, in q:
        foreach term, t_p, in p:
            add(r, t_q * t_p)


2. Division Pseudocode
{pre: for polynomials p and q passed in, all terms must be unique in degree(cannot have 2+ terms sharing degrees)}
r = p % q:
    set r to be empty
    set c_p to be empty
    set c_q to be empty
    for(int i = p.highest_degree; i > 0; i--) REPEAT i = 1 twice before ending loop (first two degrees are 1)
        if i == p.expt
            add current coefficient (num) to c_p
        else
            add new num to p with 0 coefficient.

    for(int i = q.highest_degree; i > 0; i--) REPEAT i = 1 twice before ending loop (first two degrees are 1)
            if i == q.expt
                add current coefficient (num) to c_q
            else
                add new num to c_q with 0 coefficient.

    //long division
    {inv: 0 <= i < k <= c_p.size() -1 ^ c_q lies in between c_p[i] and c_p[k]}
        int i = 0;
        while(i + c_q.size() <= c_p.size()) // i + c_q.size() = k
            add c_p[i] / c_q[i] to r // Building our answer.
            for(int j = 0; j < c_q.size(); j++) // j keeps track inside c_q; i + j keeps track inside c_p
                multiply c_q[j] by (c_p[i] / c_q[i]) // comparing divisor to numerator and preparing divisor
                int difference = sub(c_p[j], c_q[j]) // Doing the subtraction and storing in c_p
                c_p[i + j] = difference

            foreach num in c_p
                if find first non-zero
                    set i = num







3. Division Example: (x3+x-1) / (x+1) = x2-x+2




## Part 1
###########################################################################

1. Weakened Rep Invariant

    a. You would first have to change the RatNum(int n, int d) constructor and remove the part where it finds the gcf and
    divides n and d by it. This is advantageous since the constructor is now more succinct, efficient, and easier to
    implement since less code and complication is required.

    b. We would also have to change our checkRep() function since it doesn't need to uphold the assumptions that RatNum
    is simplified. This easier to implement since it means less code is more efficent since we are running one less
    method.

    c. We would need to change the hashCode() method to include simplifying both the numer and demon using the gcf()
    method. If this isn't done, then the hashcode will not match for fractions that are the same number but with
    different numerators and denominators. This change is disadvantageous, since it adds more complexity and code to
    implement inside this one function.

    d. The equals method would also have to be changed since the same number can now have different numerators and
    denominators. This ends up breaking the equals() since it assumes each number has a unique numer and denom.
    Dividing the numer and denom by gcf(numer, denom) before the method checks if they're equal would
    solve this issue. This change would be disadvantageous though, since it adds more complexity and code to
    implement inside this one function.

    e. The toString() method must be changed to divide the numer and denom by gcf(numer, denom) since the spec
    requires the returned string be in reduced terms. Making this change would be disadvantageous since it adds
    more complexity and implementation.


2. Alternate add, sub, mul, div

    a. For starters, it would violate the specification that a RatNum must be immutable, since our numer and denom fields
    get changed every time one of these operation methods gets run.

    b. We would also need to add an @spec.effects tag before each method since we are now modifying
    this' concrete fields.

    c. The div() method would also need to add to its @spec.requires that arg must not be negative, since that could
     break our rep invariant for this by making the dominator negative.

3. Constructor checkReps

    It is sufficient to call checkRep() only at the end of the constructors because the object RatNum
    and its fields are immutable, final, and none of RatNum's methods actually modify numer and denom (which is important since
    the rep invariant depends on numer and denom). Changes to instances of RatNum are prevented through a combination of
    using copying, final (immutability), and private.


## Part 2
###########################################################################

1. Calls to checkRep in RatTerm



2. Weakened Rep Invariant



3. Alternate Rep Invariant



4. Preferred Invariants




## Part 3
###########################################################################

1. Calls to checkRep in RatPoly



2. Alternate Representation



