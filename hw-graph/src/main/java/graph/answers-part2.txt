## CSE 331 hw-graph Part 2 Questions

NOTE: This file is used as part of hw-graph-part2, and is not due as part of the hw-graph-part1
submission. You may leave it blank for hw-graph-part1.

## Section 1
###########################################################################

A few examples of possible Graph representations:

    A: A collection of edges.
    B: An adjacency list, in which each node is associated with a list of its outgoing edges.
    C: An adjacency matrix, which explicitly represents, for every pair ⟨A,B⟩ of edges, whether there is a link from A to B, and how many.

1. In two or three sentences, explain an advantage and a disadvantage of each of the
representations listed above (for example, in terms of runtime complexity, space
complexity, or ease of implementation).

    A: Relatively easy to implement, since you can easily access each edge in the Graph through a high abstraction.
    Is at a disadvantage when it comes to searching nodes, since they will be hidden under a layer of abstraction.

    B: Relatively fast at creating a graph and adding nodes and edges. This representation is
    disadvantaged when it comes to removing vertices and edges though, since it needs to find all
    vertices or edges.

    C: Relatively fast at adding and removing edges, but very slow when it comes to adding and removing
    nodes, since the matrix must be resized/copied every time.

2. In two to three sentences, describe the representation you chose and explain why you
chose it. If you chose to use a different representation than one of the three we described
above, be sure to list its advantages and disadvantages, too.

    - I originally decided on a mix between a collection of edges and an adjacency list. The choice to have both
    is somewhat of an artifact from the previous version of my Graph, where I wanted nodes and edges
    to be their own public objects that the user could create and manipulate separately. I wanted both
    edges and nodes to store the information of their place in the graph separately, and so I implemented
    both a collection of edges and an adjacency list. When I moved to make both of those inner classes
    private, I moved my representation to just be an adjacency list where nodes store adjacent edges
    instead of adjacent nodes because of its time complexity advantages with adding nodes and edges.

## Section 4
###########################################################################

    (Please keep your answers brief and to-the-point.)

1. Describe any new tests you added and why you added them, or why you feel that your original
tests alone are sufficient.

    - Got rid of testing suite for setNode() and getNode() since I removed those methods/functionality.
    - Added empty graph stuff.
    - Added testing all of my @throws.
    - Added testing for all methods returning true when expected.
    - Added testing for all methods to throw IllegalArgumentException when expected.
    - Added testing all methods with an empty graph to see if they return the expected output and behave
        the correct way.
    - Added testing for proper behavior when adding duplicate nodes and edges.



2. Did you make any changes to your specifications as you were implementing your Graph? (yes/no)
If yes, describe your changes and why you made them.



